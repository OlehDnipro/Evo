struct ShBaseCoef
{
	float4 coef[3];
};
struct ShPoly
{
	int4 coef[3];// multiplied by 1000 000
};
struct ShPoly3Channel
{ 
	ShBaseCoef channels[3];
};
[Permutations]
PERMUTATIONS_BEGIN
	MUTE ComputeBase COMPUTE_BASE
	MUTE ComputeTex COMPUTE_TEX
PERMUTATIONS_END
[Rootsig]
ROOT_BEGIN

	ST_BEGIN Samplers
		SAMPLER		SamplerState ColorSampler;
	ST_END
	RT_BEGIN Resources
		CBUFFER ShPoly3Channel  SHAverage;
		TEXTURE Texture2DArray<float4> EnvTex;
		RWTEXTURE RWTexture2DArray<float4> OutTex;

		RWSTRUCTUREDBUFFER RWStructuredBuffer<ShBaseCoef> ShBase;
		RWSTRUCTUREDBUFFER RWStructuredBuffer<ShPoly> ShSum;
	RT_END
ROOT_END
[Compute: CS]

#define Face_Top 0   
#define Face_Bottom 1  
#define Face_Back 2 
#define Face_Forward 3  
#define Face_Left 4 
#define Face_Right 5  
groupshared ShPoly ShSumTemp[3];
[numthreads(32, 32, 1)]
void main(uint3 DTid : SV_DispatchThreadID) 
{
	uint2 res= uint2(1024,1024);
	uint x = DTid.x;
	uint y = DTid.y;
	uint face = DTid.z;
	if(x >= res.x || y >= res.y || face >=6 )
		return;
#ifdef COMPUTE_BASE	
	ShSumTemp[0] = (ShPoly)0;
	ShSumTemp[1] = (ShPoly)0;
	ShSumTemp[2] = (ShPoly)0;

	GroupMemoryBarrierWithGroupSync();
	// Calculate directional vector  
   // TODO: Correct direction to sample center of texel.  
   float3 direction = normalize(float3((float)x / (float)(res.x - 1) * 2.0f - 1.0f, (float)y / (float)(res.y - 1) * 2.0f - 1.0f, -1.0f));  
   
   // Rotate to match cubemap face  
   switch (face)  
   {  
	 case Face_Back:  
	 {  
	   direction[0] *= -1.0f;  
	   direction[2] *= -1.0f;  
	 }break;  
	 case Face_Left:  
	 {  
	   float const temp = direction[0];  
	   direction[0] = direction[2];  
	   direction[2] = -temp;  
	 } break;  
	 case Face_Right:  
	 {  
	   float const temp = direction[0];  
	   direction[0] = -direction[2];  
	   direction[2] = temp;  
	 } break;  
	 case Face_Top:  
	 {  
	   float const temp = direction[1];  
	   direction[1] = -direction[2];  
	   direction[2] = temp;  
	 } break;  
	 case Face_Bottom:  
	 {  
	   float const temp = direction[1];  
	   direction[1] = direction[2];  
	   direction[2] = -temp;  
	 } break;  
	 default:  
	   break;  
   } 
   
   uint index = x + y*res.x + face*res.x*res.y;

	ShBaseCoef shTemp;
   shTemp.coef[0].x = 0.282095;  
   shTemp.coef[0].y = 0.488603 * direction[1];  
   shTemp.coef[0].z = 0.488603 * direction[2];  
   shTemp.coef[0].w = 0.488603 * direction[0];  
   shTemp.coef[1].x = 1.092548 * direction[0] * direction[1];  
   shTemp.coef[1].y = 1.092548 * direction[1] * direction[2];  
   shTemp.coef[1].z = 0.315392 * (3.0 * direction[2] * direction[2] - 1.0);  
   shTemp.coef[1].w = 1.092548 * direction[0] * direction[2];  
   shTemp.coef[2].x = 0.546274 * (direction[0] * direction[0] - direction[1] * direction[1]);  
   ShBase[index] =  shTemp;
	float4 color = EnvTex.SampleLevel(ColorSampler, int3(x,y,face),0);
	[unroll]	
	for(int ch = 0; ch < 3; ch++)
	{

		InterlockedAdd(ShSumTemp[ch].coef[0].x, (int)1000000*color[ch]*shTemp.coef[0].x);
		InterlockedAdd(ShSumTemp[ch].coef[0].y, (int)1000000*color[ch]*shTemp.coef[0].y);
		InterlockedAdd(ShSumTemp[ch].coef[0].z, (int)1000000*color[ch]*shTemp.coef[0].z);

		InterlockedAdd(ShSumTemp[ch].coef[0].w, (int)1000000*color[ch]*shTemp.coef[0].w);
		InterlockedAdd(ShSumTemp[ch].coef[1].x, (int)1000000*color[ch]*shTemp.coef[1].x);
		InterlockedAdd(ShSumTemp[ch].coef[1].y, (int)1000000*color[ch]*shTemp.coef[1].y);

		InterlockedAdd(ShSumTemp[ch].coef[1].z, (int)1000000*color[ch]*shTemp.coef[1].z);
		InterlockedAdd(ShSumTemp[ch].coef[1].w, (int)1000000*color[ch]*shTemp.coef[1].w);
		InterlockedAdd(ShSumTemp[ch].coef[2].x, (int)1000000*color[ch]*shTemp.coef[2].x);

		InterlockedAdd(ShSumTemp[ch].coef[2].y, 1);
	}
	
	GroupMemoryBarrierWithGroupSync();
	uint2 sum_size = uint2((res.x - 1) / 32 + 1, (res.y - 1) / 32 + 1);
	uint buf_size = sum_size.x*sum_size.y * 6;
	uint sum_index = x / 32 + ( y / 32 )*sum_size.x + face*sum_size.x*sum_size.y;
	for(int _ch = 0; _ch < 3; _ch++)
	{
		ShSum[_ch*buf_size + sum_index] = ShSumTemp[_ch];
	}
#else
   uint index = x + y*res.x + face*res.x*res.y;

	float3 outColor = float3(0,0,0);
	ShBaseCoef shDir = ShBase[index];

	[unroll]
	for(int ch = 0; ch < 3; ch++)
	{
		ShBaseCoef curCoef = SHAverage.channels[ch];
		outColor[ch] += curCoef.coef[0].x*shDir.coef[0].x;
		outColor[ch] += curCoef.coef[0].y*shDir.coef[0].y;
		outColor[ch] += curCoef.coef[0].z*shDir.coef[0].z;

		outColor[ch] += curCoef.coef[0].w*shDir.coef[0].w;
		outColor[ch] += curCoef.coef[1].x*shDir.coef[1].x;
		outColor[ch] += curCoef.coef[1].y*shDir.coef[1].y;

		outColor[ch] += curCoef.coef[1].z*shDir.coef[1].z;
		outColor[ch] += curCoef.coef[1].w*shDir.coef[1].w;
		outColor[ch] += curCoef.coef[2].x*shDir.coef[2].x;

	}
	
	OutTex[uint3(x,y, face)] = float4(outColor,1 );
	
#endif
   
}

